{"metadata":{"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}},"usedHelpers":["inherits","create-class","class-call-check"]},"ignored":false,"code":"/**\n * Extend EasySearch.Index with component functionality.\n *\n * @type {Index}\n */\nEasySearch.Index = (function (_EasySearch$Index) {\n  babelHelpers.inherits(Index, _EasySearch$Index);\n\n  /**\n   * Constructor.\n   */\n\n  function Index() {\n    babelHelpers.classCallCheck(this, Index);\n\n    _EasySearch$Index.apply(this, arguments);\n    this.components = {};\n  }\n\n  /**\n   * Return static default name for components.\n   *\n   * @returns {String}\n   */\n\n  /**\n   * Register a component on the index.\n   *\n   * @param {String} componentName Optional name of the component\n   */\n\n  Index.prototype.registerComponent = (function () {\n    function registerComponent() {\n      var componentName = arguments.length <= 0 || arguments[0] === undefined ? EasySearch.Index.COMPONENT_DEFAULT_NAME : arguments[0];\n\n      this.components[componentName] = new ReactiveDict('easySearchComponent_' + this.config.name + '_' + componentName + '_' + Random.id());\n    }\n\n    return registerComponent;\n  })();\n\n  /**\n   * Get the reactive dictionary for a component.\n   *\n   * @param {String} componentName Optional name of the component\n   */\n\n  Index.prototype.getComponentDict = (function () {\n    function getComponentDict() {\n      var componentName = arguments.length <= 0 || arguments[0] === undefined ? EasySearch.Index.COMPONENT_DEFAULT_NAME : arguments[0];\n\n      return this.components[componentName];\n    }\n\n    return getComponentDict;\n  })();\n\n  /**\n   * Get component methods that are useful for implementing search behaviour.\n   *\n   * @param componentName\n   */\n\n  Index.prototype.getComponentMethods = (function () {\n    function getComponentMethods() {\n      var componentName = arguments.length <= 0 || arguments[0] === undefined ? EasySearch.Index.COMPONENT_DEFAULT_NAME : arguments[0];\n\n      var dict = this.getComponentDict(componentName);\n\n      if (!dict) {\n        throw new Meteor.Error('no-component', 'Component with name \\'' + componentName + '\\' not found');\n      }\n\n      return EasySearch._getComponentMethods(dict, this);\n    }\n\n    return getComponentMethods;\n  })();\n\n  babelHelpers.createClass(Index, null, [{\n    key: 'COMPONENT_DEFAULT_NAME',\n    get: function () {\n      return '__default';\n    }\n  }]);\n  return Index;\n})(EasySearch.Index);\n\n/**\n * Return true if the current page is valid.\n *\n * @param {Number} totalPagesLength Count of all pages available\n * @param {Number} currentPage      Current page to check\n *\n * @returns {boolean}\n */\nfunction isValidPage(totalPagesLength, currentPage) {\n  return currentPage <= totalPagesLength && currentPage > 0;\n}\n\n/**\n * Helper method to get the pages for pagination as an array.\n *\n * @param totalCount   Total count of results\n * @param pageCount    Count of results per page\n * @param currentPage  Current page\n * @param prevAndNext  True if Next and Previous buttons should appear\n * @param maxPages     Maximum count of pages to show\n *\n * @private\n *\n * @returns {Array}\n */\nEasySearch._getPagesForPagination = function (_ref) {\n  var totalCount = _ref.totalCount;\n  var pageCount = _ref.pageCount;\n  var currentPage = _ref.currentPage;\n  var prevAndNext = _ref.prevAndNext;\n  var maxPages = _ref.maxPages;\n\n  var pages = _.range(1, Math.ceil(totalCount / pageCount) + 1),\n      pagesLength = pages.length;\n\n  if (!isValidPage(pagesLength, currentPage)) {\n    throw new Meteor.Error('invalid-page', 'Current page is not in valid range');\n  }\n\n  if (maxPages) {\n    var startSlice = currentPage > maxPages / 2 ? currentPage - 1 - Math.floor(maxPages / 2) : 0,\n        endSlice = startSlice + maxPages;\n\n    if (endSlice > pagesLength) {\n      pages = pages.slice(-maxPages);\n    } else {\n      pages = pages.slice(startSlice, startSlice + maxPages);\n    }\n  }\n\n  var pageData = _.map(pages, function (page) {\n    var isCurrentPage = page === currentPage;\n    return { page: page, content: page.toString(), current: isCurrentPage, disabled: isCurrentPage };\n  });\n\n  if (prevAndNext) {\n    // Previous\n    var prevPage = isValidPage(pagesLength, currentPage - 1) ? currentPage - 1 : null;\n    pageData.unshift({ page: prevPage, content: 'Prev', current: false, disabled: 1 === currentPage });\n    // Next\n    var nextPage = isValidPage(pagesLength, currentPage + 1) ? currentPage + 1 : null;\n    pageData.push({ page: nextPage, content: 'Next', current: false, disabled: null == nextPage || pagesLength + 1 === currentPage });\n  }\n\n  return pageData;\n};","ast":null,"map":{"version":3,"sources":["/lib/core.js"],"names":[],"mappings":"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","file":"/lib/core.js.map","sourcesContent":["/**\n * Extend EasySearch.Index with component functionality.\n *\n * @type {Index}\n */\nEasySearch.Index = class Index extends EasySearch.Index {\n  /**\n   * Constructor.\n   */\n  constructor() {\n    super(...arguments);\n    this.components = {};\n  }\n\n  /**\n   * Return static default name for components.\n   *\n   * @returns {String}\n   */\n  static get COMPONENT_DEFAULT_NAME() {\n    return'__default';\n  }\n\n  /**\n   * Register a component on the index.\n   *\n   * @param {String} componentName Optional name of the component\n   */\n  registerComponent(componentName = EasySearch.Index.COMPONENT_DEFAULT_NAME) {\n    this.components[componentName] = new ReactiveDict(`easySearchComponent_${this.config.name}_${componentName}_${Random.id()}`);\n  }\n\n  /**\n   * Get the reactive dictionary for a component.\n   *\n   * @param {String} componentName Optional name of the component\n   */\n  getComponentDict(componentName = EasySearch.Index.COMPONENT_DEFAULT_NAME) {\n    return this.components[componentName];\n  }\n\n  /**\n   * Get component methods that are useful for implementing search behaviour.\n   *\n   * @param componentName\n   */\n  getComponentMethods(componentName = EasySearch.Index.COMPONENT_DEFAULT_NAME) {\n    let dict = this.getComponentDict(componentName);\n\n    if (!dict) {\n      throw new Meteor.Error('no-component', `Component with name '${componentName}' not found`);\n    }\n\n    return EasySearch._getComponentMethods(dict, this);\n  }\n};\n\n/**\n * Return true if the current page is valid.\n *\n * @param {Number} totalPagesLength Count of all pages available\n * @param {Number} currentPage      Current page to check\n *\n * @returns {boolean}\n */\nfunction isValidPage(totalPagesLength, currentPage) {\n  return currentPage <= totalPagesLength && currentPage > 0;\n}\n\n/**\n * Helper method to get the pages for pagination as an array.\n *\n * @param totalCount   Total count of results\n * @param pageCount    Count of results per page\n * @param currentPage  Current page\n * @param prevAndNext  True if Next and Previous buttons should appear\n * @param maxPages     Maximum count of pages to show\n *\n * @private\n *\n * @returns {Array}\n */\nEasySearch._getPagesForPagination = function ({totalCount, pageCount, currentPage, prevAndNext, maxPages}) {\n  let pages = _.range(1, Math.ceil(totalCount / pageCount) + 1),\n    pagesLength = pages.length;\n\n  if (!isValidPage(pagesLength, currentPage)) {\n    throw new Meteor.Error('invalid-page', 'Current page is not in valid range');\n  }\n\n  if (maxPages) {\n    let startSlice = (currentPage > (maxPages / 2) ? (currentPage - 1) - Math.floor(maxPages / 2) : 0),\n      endSlice = startSlice + maxPages;\n\n    if (endSlice > pagesLength) {\n      pages = pages.slice(-maxPages);\n    } else {\n      pages = pages.slice(startSlice, startSlice + maxPages);\n    }\n  }\n\n  let pageData = _.map(pages, function (page) {\n    let isCurrentPage = page === currentPage;\n    return { page, content: page.toString(), current: isCurrentPage, disabled: isCurrentPage };\n  });\n\n  if (prevAndNext) {\n    // Previous\n    let prevPage = isValidPage(pagesLength, currentPage - 1) ? currentPage - 1 : null;\n    pageData.unshift({ page: prevPage, content: 'Prev', current: false, disabled: 1 === currentPage });\n    // Next\n    let nextPage = isValidPage(pagesLength, currentPage + 1) ? currentPage + 1 : null;\n    pageData.push(\n      { page: nextPage, content: 'Next', current: false, disabled: null == nextPage || pagesLength + 1 === currentPage }\n    );\n  }\n\n  return pageData;\n};\n"]},"hash":"adf85bfa8c8e21cbb092ee6bda7c454f38954e25"}
