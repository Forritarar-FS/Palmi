{"version":3,"sources":["meteor://ðŸ’»app/packages/peerlibrary_assert/packages/peerlibrary_assert.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8F","file":"/packages/peerlibrary_assert.js","sourcesContent":["(function () {\n\n///////////////////////////////////////////////////////////////////////////////////\n//                                                                               //\n// packages/peerlibrary:assert/client/assert.js                                  //\n//                                                                               //\n///////////////////////////////////////////////////////////////////////////////////\n                                                                                 //\n// http://wiki.commonjs.org/wiki/Unit_Testing/1.0                                // 1\n//                                                                               // 2\n// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!                             // 3\n//                                                                               // 4\n// Copyright (c) 2011 Jxck                                                       // 5\n//                                                                               // 6\n// Originally from node.js (http://nodejs.org)                                   // 7\n// Copyright Joyent, Inc.                                                        // 8\n//                                                                               // 9\n// Permission is hereby granted, free of charge, to any person obtaining a copy  // 10\n// of this software and associated documentation files (the 'Software'), to      // 11\n// deal in the Software without restriction, including without limitation the    // 12\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or   // 13\n// sell copies of the Software, and to permit persons to whom the Software is    // 14\n// furnished to do so, subject to the following conditions:                      // 15\n//                                                                               // 16\n// The above copyright notice and this permission notice shall be included in    // 17\n// all copies or substantial portions of the Software.                           // 18\n//                                                                               // 19\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR    // 20\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,      // 21\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE   // 22\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN    // 23\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION  // 24\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.               // 25\n                                                                                 // 26\n(function(global) {                                                              // 27\n                                                                                 // 28\n// Object.create compatible in IE                                                // 29\nvar create = Object.create || function(p) {                                      // 30\n  if (!p) throw Error('no type');                                                // 31\n  function f() {};                                                               // 32\n  f.prototype = p;                                                               // 33\n  return new f();                                                                // 34\n};                                                                               // 35\n                                                                                 // 36\n// UTILITY                                                                       // 37\nvar util = {                                                                     // 38\n  inherits: function(ctor, superCtor) {                                          // 39\n    ctor.super_ = superCtor;                                                     // 40\n    ctor.prototype = create(superCtor.prototype, {                               // 41\n      constructor: {                                                             // 42\n        value: ctor,                                                             // 43\n        enumerable: false,                                                       // 44\n        writable: true,                                                          // 45\n        configurable: true                                                       // 46\n      }                                                                          // 47\n    });                                                                          // 48\n  },                                                                             // 49\n  isArray: function(ar) {                                                        // 50\n    return Array.isArray(ar);                                                    // 51\n  },                                                                             // 52\n  isBoolean: function(arg) {                                                     // 53\n    return typeof arg === 'boolean';                                             // 54\n  },                                                                             // 55\n  isNull: function(arg) {                                                        // 56\n    return arg === null;                                                         // 57\n  },                                                                             // 58\n  isNullOrUndefined: function(arg) {                                             // 59\n    return arg == null;                                                          // 60\n  },                                                                             // 61\n  isNumber: function(arg) {                                                      // 62\n    return typeof arg === 'number';                                              // 63\n  },                                                                             // 64\n  isString: function(arg) {                                                      // 65\n    return typeof arg === 'string';                                              // 66\n  },                                                                             // 67\n  isSymbol: function(arg) {                                                      // 68\n    return typeof arg === 'symbol';                                              // 69\n  },                                                                             // 70\n  isUndefined: function(arg) {                                                   // 71\n    return arg === void 0;                                                       // 72\n  },                                                                             // 73\n  isRegExp: function(re) {                                                       // 74\n    return util.isObject(re) && util.objectToString(re) === '[object RegExp]';   // 75\n  },                                                                             // 76\n  isObject: function(arg) {                                                      // 77\n    return typeof arg === 'object' && arg !== null;                              // 78\n  },                                                                             // 79\n  isDate: function(d) {                                                          // 80\n    return util.isObject(d) && util.objectToString(d) === '[object Date]';       // 81\n  },                                                                             // 82\n  isError: function(e) {                                                         // 83\n    return isObject(e) &&                                                        // 84\n      (objectToString(e) === '[object Error]' || e instanceof Error);            // 85\n  },                                                                             // 86\n  isFunction: function(arg) {                                                    // 87\n    return typeof arg === 'function';                                            // 88\n  },                                                                             // 89\n  isPrimitive: function(arg) {                                                   // 90\n    return arg === null ||                                                       // 91\n      typeof arg === 'boolean' ||                                                // 92\n      typeof arg === 'number' ||                                                 // 93\n      typeof arg === 'string' ||                                                 // 94\n      typeof arg === 'symbol' ||  // ES6 symbol                                  // 95\n      typeof arg === 'undefined';                                                // 96\n  },                                                                             // 97\n  objectToString: function(o) {                                                  // 98\n    return Object.prototype.toString.call(o);                                    // 99\n  }                                                                              // 100\n};                                                                               // 101\n                                                                                 // 102\nvar pSlice = Array.prototype.slice;                                              // 103\n                                                                                 // 104\n// from https://github.com/substack/node-deep-equal                              // 105\nvar Object_keys = typeof Object.keys === 'function'                              // 106\n    ? Object.keys                                                                // 107\n    : function (obj) {                                                           // 108\n        var keys = [];                                                           // 109\n        for (var key in obj) keys.push(key);                                     // 110\n        return keys;                                                             // 111\n    }                                                                            // 112\n;                                                                                // 113\n                                                                                 // 114\n// 1. The assert module provides functions that throw                            // 115\n// AssertionError's when particular conditions are not met. The                  // 116\n// assert module must conform to the following interface.                        // 117\n                                                                                 // 118\nvar assert = ok;                                                                 // 119\n                                                                                 // 120\nglobal['assert'] = assert;                                                       // 121\n                                                                                 // 122\nif (typeof module === 'object' && typeof module.exports === 'object') {          // 123\n  module.exports = assert;                                                       // 124\n};                                                                               // 125\n                                                                                 // 126\n// 2. The AssertionError is defined in assert.                                   // 127\n// new assert.AssertionError({ message: message,                                 // 128\n//                             actual: actual,                                   // 129\n//                             expected: expected })                             // 130\n                                                                                 // 131\nassert.AssertionError = function AssertionError(options) {                       // 132\n  this.name = 'AssertionError';                                                  // 133\n  this.actual = options.actual;                                                  // 134\n  this.expected = options.expected;                                              // 135\n  this.operator = options.operator;                                              // 136\n  if (options.message) {                                                         // 137\n    this.message = options.message;                                              // 138\n    this.generatedMessage = false;                                               // 139\n  } else {                                                                       // 140\n    this.message = getMessage(this);                                             // 141\n    this.generatedMessage = true;                                                // 142\n  }                                                                              // 143\n  var stackStartFunction = options.stackStartFunction || fail;                   // 144\n                                                                                 // 145\n  if (Error.captureStackTrace) {                                                 // 146\n    Error.captureStackTrace(this, stackStartFunction);                           // 147\n  } else {                                                                       // 148\n    // try to throw an error now, and from the stack property                    // 149\n    // work out the line that called in to assert.js.                            // 150\n    try {                                                                        // 151\n      this.stack = (new Error).stack.toString();                                 // 152\n    } catch (e) {}                                                               // 153\n  }                                                                              // 154\n};                                                                               // 155\n                                                                                 // 156\n// assert.AssertionError instanceof Error                                        // 157\nutil.inherits(assert.AssertionError, Error);                                     // 158\n                                                                                 // 159\nfunction replacer(key, value) {                                                  // 160\n  if (util.isUndefined(value)) {                                                 // 161\n    return '' + value;                                                           // 162\n  }                                                                              // 163\n  if (util.isNumber(value) && (isNaN(value) || !isFinite(value))) {              // 164\n    return value.toString();                                                     // 165\n  }                                                                              // 166\n  if (util.isFunction(value) || util.isRegExp(value)) {                          // 167\n    return value.toString();                                                     // 168\n  }                                                                              // 169\n  return value;                                                                  // 170\n}                                                                                // 171\n                                                                                 // 172\nfunction truncate(s, n) {                                                        // 173\n  if (util.isString(s)) {                                                        // 174\n    return s.length < n ? s : s.slice(0, n);                                     // 175\n  } else {                                                                       // 176\n    return s;                                                                    // 177\n  }                                                                              // 178\n}                                                                                // 179\n                                                                                 // 180\nfunction getMessage(self) {                                                      // 181\n  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +            // 182\n         self.operator + ' ' +                                                   // 183\n         truncate(JSON.stringify(self.expected, replacer), 128);                 // 184\n}                                                                                // 185\n                                                                                 // 186\n// At present only the three keys mentioned above are used and                   // 187\n// understood by the spec. Implementations or sub modules can pass               // 188\n// other keys to the AssertionError's constructor - they will be                 // 189\n// ignored.                                                                      // 190\n                                                                                 // 191\n// 3. All of the following functions must throw an AssertionError                // 192\n// when a corresponding condition is not met, with a message that                // 193\n// may be undefined if not provided.  All assertion methods provide              // 194\n// both the actual and expected values to the assertion error for                // 195\n// display purposes.                                                             // 196\n                                                                                 // 197\nfunction fail(actual, expected, message, operator, stackStartFunction) {         // 198\n  throw new assert.AssertionError({                                              // 199\n    message: message,                                                            // 200\n    actual: actual,                                                              // 201\n    expected: expected,                                                          // 202\n    operator: operator,                                                          // 203\n    stackStartFunction: stackStartFunction                                       // 204\n  });                                                                            // 205\n}                                                                                // 206\n                                                                                 // 207\n// EXTENSION! allows for well behaved errors defined elsewhere.                  // 208\nassert.fail = fail;                                                              // 209\n                                                                                 // 210\n// 4. Pure assertion tests whether a value is truthy, as determined              // 211\n// by !!guard.                                                                   // 212\n// assert.ok(guard, message_opt);                                                // 213\n// This statement is equivalent to assert.equal(true, !!guard,                   // 214\n// message_opt);. To test strictly for the value true, use                       // 215\n// assert.strictEqual(true, guard, message_opt);.                                // 216\n                                                                                 // 217\nfunction ok(value, message) {                                                    // 218\n  if (!value) fail(value, true, message, '==', assert.ok);                       // 219\n}                                                                                // 220\nassert.ok = ok;                                                                  // 221\n                                                                                 // 222\n// 5. The equality assertion tests shallow, coercive equality with               // 223\n// ==.                                                                           // 224\n// assert.equal(actual, expected, message_opt);                                  // 225\n                                                                                 // 226\nassert.equal = function equal(actual, expected, message) {                       // 227\n  if (actual != expected) fail(actual, expected, message, '==', assert.equal);   // 228\n};                                                                               // 229\n                                                                                 // 230\n// 6. The non-equality assertion tests for whether two objects are not equal     // 231\n// with != assert.notEqual(actual, expected, message_opt);                       // 232\n                                                                                 // 233\nassert.notEqual = function notEqual(actual, expected, message) {                 // 234\n  if (actual == expected) {                                                      // 235\n    fail(actual, expected, message, '!=', assert.notEqual);                      // 236\n  }                                                                              // 237\n};                                                                               // 238\n                                                                                 // 239\n// 7. The equivalence assertion tests a deep equality relation.                  // 240\n// assert.deepEqual(actual, expected, message_opt);                              // 241\n                                                                                 // 242\nassert.deepEqual = function deepEqual(actual, expected, message) {               // 243\n  if (!_deepEqual(actual, expected)) {                                           // 244\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);              // 245\n  }                                                                              // 246\n};                                                                               // 247\n                                                                                 // 248\nfunction _deepEqual(actual, expected) {                                          // 249\n  // 7.1. All identical values are equivalent, as determined by ===.             // 250\n  if (actual === expected) {                                                     // 251\n    return true;                                                                 // 252\n                                                                                 // 253\n  // } else if (util.isBuffer(actual) && util.isBuffer(expected)) {              // 254\n  //   if (actual.length != expected.length) return false;                       // 255\n  //                                                                             // 256\n  //   for (var i = 0; i < actual.length; i++) {                                 // 257\n  //     if (actual[i] !== expected[i]) return false;                            // 258\n  //   }                                                                         // 259\n  //                                                                             // 260\n  //   return true;                                                              // 261\n                                                                                 // 262\n  // 7.2. If the expected value is a Date object, the actual value is            // 263\n  // equivalent if it is also a Date object that refers to the same time.        // 264\n  } else if (util.isDate(actual) && util.isDate(expected)) {                     // 265\n    return actual.getTime() === expected.getTime();                              // 266\n                                                                                 // 267\n  // 7.3 If the expected value is a RegExp object, the actual value is           // 268\n  // equivalent if it is also a RegExp object with the same source and           // 269\n  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).              // 270\n  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {                 // 271\n    return actual.source === expected.source &&                                  // 272\n           actual.global === expected.global &&                                  // 273\n           actual.multiline === expected.multiline &&                            // 274\n           actual.lastIndex === expected.lastIndex &&                            // 275\n           actual.ignoreCase === expected.ignoreCase;                            // 276\n                                                                                 // 277\n  // 7.4. Other pairs that do not both pass typeof value == 'object',            // 278\n  // equivalence is determined by ==.                                            // 279\n  } else if (!util.isObject(actual) && !util.isObject(expected)) {               // 280\n    return actual == expected;                                                   // 281\n                                                                                 // 282\n  // 7.5 For all other Object pairs, including Array objects, equivalence is     // 283\n  // determined by having the same number of owned properties (as verified       // 284\n  // with Object.prototype.hasOwnProperty.call), the same set of keys            // 285\n  // (although not necessarily the same order), equivalent values for every      // 286\n  // corresponding key, and an identical 'prototype' property. Note: this        // 287\n  // accounts for both named and indexed properties on Arrays.                   // 288\n  } else {                                                                       // 289\n    return objEquiv(actual, expected);                                           // 290\n  }                                                                              // 291\n}                                                                                // 292\n                                                                                 // 293\nfunction isArguments(object) {                                                   // 294\n  return Object.prototype.toString.call(object) == '[object Arguments]';         // 295\n}                                                                                // 296\n                                                                                 // 297\nfunction objEquiv(a, b) {                                                        // 298\n  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))                    // 299\n    return false;                                                                // 300\n  // an identical 'prototype' property.                                          // 301\n  if (a.prototype !== b.prototype) return false;                                 // 302\n  //~~~I've managed to break Object.keys through screwy arguments passing.       // 303\n  //   Converting to array solves the problem.                                   // 304\n  if (isArguments(a)) {                                                          // 305\n    if (!isArguments(b)) {                                                       // 306\n      return false;                                                              // 307\n    }                                                                            // 308\n    a = pSlice.call(a);                                                          // 309\n    b = pSlice.call(b);                                                          // 310\n    return _deepEqual(a, b);                                                     // 311\n  }                                                                              // 312\n  try {                                                                          // 313\n    var ka = Object_keys(a),                                                     // 314\n        kb = Object_keys(b),                                                     // 315\n        key, i;                                                                  // 316\n  } catch (e) {//happens when one is a string literal and the other isn't        // 317\n    return false;                                                                // 318\n  }                                                                              // 319\n  // having the same number of owned properties (keys incorporates               // 320\n  // hasOwnProperty)                                                             // 321\n  if (ka.length != kb.length)                                                    // 322\n    return false;                                                                // 323\n  //the same set of keys (although not necessarily the same order),              // 324\n  ka.sort();                                                                     // 325\n  kb.sort();                                                                     // 326\n  //~~~cheap key test                                                            // 327\n  for (i = ka.length - 1; i >= 0; i--) {                                         // 328\n    if (ka[i] != kb[i])                                                          // 329\n      return false;                                                              // 330\n  }                                                                              // 331\n  //equivalent values for every corresponding key, and                           // 332\n  //~~~possibly expensive deep test                                              // 333\n  for (i = ka.length - 1; i >= 0; i--) {                                         // 334\n    key = ka[i];                                                                 // 335\n    if (!_deepEqual(a[key], b[key])) return false;                               // 336\n  }                                                                              // 337\n  return true;                                                                   // 338\n}                                                                                // 339\n                                                                                 // 340\n// 8. The non-equivalence assertion tests for any deep inequality.               // 341\n// assert.notDeepEqual(actual, expected, message_opt);                           // 342\n                                                                                 // 343\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {         // 344\n  if (_deepEqual(actual, expected)) {                                            // 345\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);        // 346\n  }                                                                              // 347\n};                                                                               // 348\n                                                                                 // 349\n// 9. The strict equality assertion tests strict equality, as determined by ===. // 350\n// assert.strictEqual(actual, expected, message_opt);                            // 351\n                                                                                 // 352\nassert.strictEqual = function strictEqual(actual, expected, message) {           // 353\n  if (actual !== expected) {                                                     // 354\n    fail(actual, expected, message, '===', assert.strictEqual);                  // 355\n  }                                                                              // 356\n};                                                                               // 357\n                                                                                 // 358\n// 10. The strict non-equality assertion tests for strict inequality, as         // 359\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);     // 360\n                                                                                 // 361\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {     // 362\n  if (actual === expected) {                                                     // 363\n    fail(actual, expected, message, '!==', assert.notStrictEqual);               // 364\n  }                                                                              // 365\n};                                                                               // 366\n                                                                                 // 367\nfunction expectedException(actual, expected) {                                   // 368\n  if (!actual || !expected) {                                                    // 369\n    return false;                                                                // 370\n  }                                                                              // 371\n                                                                                 // 372\n  if (Object.prototype.toString.call(expected) == '[object RegExp]') {           // 373\n    return expected.test(actual);                                                // 374\n  } else if (actual instanceof expected) {                                       // 375\n    return true;                                                                 // 376\n  } else if (expected.call({}, actual) === true) {                               // 377\n    return true;                                                                 // 378\n  }                                                                              // 379\n                                                                                 // 380\n  return false;                                                                  // 381\n}                                                                                // 382\n                                                                                 // 383\nfunction _throws(shouldThrow, block, expected, message) {                        // 384\n  var actual;                                                                    // 385\n                                                                                 // 386\n  if (util.isString(expected)) {                                                 // 387\n    message = expected;                                                          // 388\n    expected = null;                                                             // 389\n  }                                                                              // 390\n                                                                                 // 391\n  try {                                                                          // 392\n    block();                                                                     // 393\n  } catch (e) {                                                                  // 394\n    actual = e;                                                                  // 395\n  }                                                                              // 396\n                                                                                 // 397\n  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +    // 398\n            (message ? ' ' + message : '.');                                     // 399\n                                                                                 // 400\n  if (shouldThrow && !actual) {                                                  // 401\n    fail(actual, expected, 'Missing expected exception' + message);              // 402\n  }                                                                              // 403\n                                                                                 // 404\n  if (!shouldThrow && expectedException(actual, expected)) {                     // 405\n    fail(actual, expected, 'Got unwanted exception' + message);                  // 406\n  }                                                                              // 407\n                                                                                 // 408\n  if ((shouldThrow && actual && expected &&                                      // 409\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {       // 410\n    throw actual;                                                                // 411\n  }                                                                              // 412\n}                                                                                // 413\n                                                                                 // 414\n// 11. Expected to throw an error:                                               // 415\n// assert.throws(block, Error_opt, message_opt);                                 // 416\n                                                                                 // 417\nassert.throws = function(block, /*optional*/error, /*optional*/message) {        // 418\n  _throws.apply(this, [true].concat(pSlice.call(arguments)));                    // 419\n};                                                                               // 420\n                                                                                 // 421\n// EXTENSION! This is annoying to write outside this module.                     // 422\nassert.doesNotThrow = function(block, /*optional*/message) {                     // 423\n  _throws.apply(this, [false].concat(pSlice.call(arguments)));                   // 424\n};                                                                               // 425\n                                                                                 // 426\nassert.ifError = function(err) { if (err) {throw err;}};                         // 427\n                                                                                 // 428\nif (typeof define === 'function' && define.amd) {                                // 429\n  define('assert', function () {                                                 // 430\n    return assert;                                                               // 431\n  });                                                                            // 432\n}                                                                                // 433\n                                                                                 // 434\n})(this);                                                                        // 435\n                                                                                 // 436\n                                                                                 // 437\n///////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function () {\n\n///////////////////////////////////////////////////////////////////////////////////\n//                                                                               //\n// packages/peerlibrary:assert/export-assert.js                                  //\n//                                                                               //\n///////////////////////////////////////////////////////////////////////////////////\n                                                                                 //\nassert = this.assert;                                                            // 1\n///////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n"]}